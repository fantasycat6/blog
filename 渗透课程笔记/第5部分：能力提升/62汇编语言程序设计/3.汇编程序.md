##  3. 汇编程序

经过上述课程的学习，我们可以编写一个完整的程序了。这章开始我们将开始编写完整的汇编语言程序，用编

译和连接程序将它们连接成可执行文件（如.exe文件）在DOS中运行。为了能够透彻地理解一个完整的程序

（尽管它看上去十分简单），我们将经历一个**漫长的过程**。

### 3.1 汇编程序的执行过程

下图描述了一个汇编程序从写出到最终执行的简要过程：

![.png](https://img.gyxnb.top/img002/828c2e32e06f4c2fad5336c63bfcdbb7.png)

**第一步：编写汇编源程序**

使用文本编辑器（记事本、Notepad++等等），用汇编语言编写汇编源程序。这一步的工作是产生了一个存储

**源程序的文本文件**

**第二步：对源程序进行编译连接**

使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件；再用连接程序对目标文件进行连接，

生成**可在操作系统直接运行的可执行文件**。

可执行的文件包含两部分内容：

- **程序**和**数据**：程序中的汇编指令翻译过来的机器码和源程序中定义的数据
- **相关的描述信息**：程序多大，要占用多少内存空间等

**第三步：执行可执行文件中的程序**

在操作系统中，执行可执行文件中的程序。此时，**操作系统依照可执行文件中的描述信息，将可执行文件中的**

**机器码和数据加载入内存，并进行相关的初始化（比如CS:IP指向第一条要执行的指令）**，然后由CPU执行程序。

### 3.2 源程序

下面我们来看一下一段简单的程序：

```assembly
assume cs:codesg
codesg segment
    mov ax,0123H
    mov bx,0456H
    add ax,bx
    add ax,ax
    
    mov ax,4C00H
    int 21H
codesg ends
end
```

下面来对这个程序进行说明。在汇编语言程序中，包含两种指令，一种是**汇编指令，一种是伪指令**。汇编指令是

有对应机器码的指令，可以被编译成机器指令，最终被CPU执行。而伪指令并没有对应的机器码，最终不会被

CPU执行，**而是会被编译器所执行**。

- 我们先来看一下上述程序中出现的伪指令。

1. xxx **segment**
   ....
   xxx **ends**
   segment 和 ends 是成对使用的伪指令，这是在写可被编译器编译的汇编程序时**必须要用到**的一对伪指令。
   segment和ends的功能是定义一个段，**segment说明一个段的开始，ends说明一个段的结束**。在汇编
   源程序中，一个**段必须要有一个名称**标识，使用格式为：
   **段名 segment**
   **..**
   **段名 ends**
   像上述的程序中：（定义了一个代码段）

   ```assembly
   codesg segment  ;定义了一个段，段的名称为codeseg，这个段从此开始
     ;..
   codesg ends ;名称为codeseg的段到此结束
   ```

   当然一个源程序可以由多个段组成，可以用来存放代码、数据或者当做栈空间来使用。一个**汇编源程序至少要有一个段**：代码段。

2. **end**
   end是一个汇编程序的结束标记，编译器在编译汇编程序的时候，如果碰到end，就会结束对源程序的编译。所以，我们在写程序的时候，程序结束的时候应该在结尾处加上伪指令end。

3. **assume**
   assume：假设，它可以用来假设某一段寄存器和程序中的某一个用segment...ends定义的段相关联。
   在编程时，我们需要使用assume将**有特定用途的段和相关的段寄存器**关联起来。
   例如上述程序中定义了一个名为codesg的代码段，我们需要将CS段寄存器和该段进行关联，格式则为：
   **assume cs:codesg**
   如果你要关联多个段：可以使用如下格式
   **assume cs:codesg ds:datasg ss:stacksg**

- 除了伪指令以外，还有最重要的**汇编指令**。
  编程的最终目的是让计算机完成一定的任务，而任务的完成由汇编指令来指示。汇编指令经过编译连接之后会转换成对应的机器码，如下图所示：

![.jpg](https://img.gyxnb.top/img002/8dfbf3c7182944a78252d7668b815ac6.jpg)

- 除了上述内容以外，我们还需要知道**codesg**的具体含义
  它被称为标号。**一个标号指代了一个地址**。上述示例中codesg在segment前面，作为一个段的名称，最终
  在编译连接之后处理为一个段的**段地址**。

认识上述的指令之后，我们再来看一下**汇编程序的结构**，从整体上来看一个汇编源程序应该需要什么。

1. 定义一个段（当然可以有多个段，但至少要有一个代码段）

   ```assembly
   ;比如  定义了一个段，段名为abc
   abc segment
   ;..
   abc ends
   ```

2. 往段中加入汇编指令

   ```assembly
   abc segment
       mov ax,2    ;这三条汇编语句的作用是求2^3
       add ax,ax
       add ax,ax
   abc ends
   ```

3. 指明程序在何处结束

   ```assembly
   abc segment
       mov ax,2    ;这三条汇编语句的作用是求2^3
       add ax,ax
       add ax,ax
   abc ends
   end
   ```

4. 指明代码段:人为设置代码段编译器并不会也这么认为

   ```assembly
   assume cs:abc
   abc segment
       mov ax,2    ;这三条汇编语句的作用是求2^3
       add ax,ax
       add ax,ax
   abc ends
   end
   ```

5. 程序返回
   上述讲解我们并没有讲述下面两条语句的作用，它们的作用是程序返回，类似于C语言中的return

   ```assembly
   mov ax,4C00H
   int 21H
   ```

   当然我们不用过多探究它们具体是什么意思，我们知道它们的功能是程序返回就可以了。
   所以上述程序还可以完善：(到此为止我们才算完成了一个较为完整的汇编源程序)

   ```assembly
   assume cs:abc
   abc segment
       mov ax,2    ;这三条汇编语句的作用是求2^3
       add ax,ax
       add ax,ax
   
       mov ax,4c00H
       int 21H
   abc ends
   end
   ```

> 源程序和程序的区别：我们称源程序文件中的所有内容成为源程序，比如1.asm中的内容。将源程序中
>
> 最终由计算机执行、处理的指令或数据称为程序。

到此为止，我们已经接触了几个和结束相关的内容：段结束、程序结束、程序返回，下图展示了它们的区别：

![.jpg](https://img.gyxnb.top/img002/76fa5dc347b641a8b92fcbb8be468b53.jpg)

### 3.3 编译

上节内容已经可以完成一个源程序的编写，我们将其保存为1.asm之后就可以得到一个源程序文件。在这

之后我们就可以对其进行编译了，下面我们来讲解编译过程。

编译需要借助于相应的编译器，我们采用的masm汇编编译器。在上一章中我们已经讲解了如何进行源程序的

编译连接过程，现在我们来详细看看编译的过程。

进入DOS，并且进入到MASM目录（我们放在虚拟C盘中，如果不是的可以使用cd指令进入对应的目录）

![masm.jpg](https://img.gyxnb.top/img002/ba94dba92d2247e5ac8ae34add61aa7c.jpg)

如上图，运行masm后，首先显示出一些版本信息，然后提示输入将要被编译的程序文件的名（【.ASM】）。

我们默认的扩展名是asm，如果要**编译的源程序文件名为p1.asm，在这里只要输入p1即可**。如果源程序文件

名字**不是asm的扩展名则需要输入全名**。比如文件名为p1.txt，就要输入全名。

当然我们输入文件名的目的是让系统根据对应的文件名找到对应的文件，我们输入文件名的时候还需要指明

这个文件的所在路径，比如文件p1.txt在c:code\下，则输入应为：c:code\p1.txt

如果你的可执行文件和masm文件在同一级目录，则可以直接输入名字即可，后续中间文件.obj同理。

使用masm编译了源文件之后会生成一个**目标文件.obj**，我们也可以制定这个文件的名字，示意如下：

![obj.jpg](https://img.gyxnb.top/img002/e292b0d7f68d4e7cb6e153a60d44d703.jpg)

上述的图片中默认生成1.OBJ，我们也可以设置为其他名字。后续还会有两个提示，分别是提示生成

**列表文件和引用文件**，当然我们可以直接忽略这两个文件，他们属于中间文件，之后一直按下Enter键即可。

最终出现如下界面：

![.jpg](https://img.gyxnb.top/img002/e7fa148740094578a9d53ded54b31bbd.jpg)

当我们完成了上述步骤之后就会出现一个新的文件1.obj。当然如果编译过程中出现错误的话将不会生成最终

的目标文件。程序出错的标志：

- **程序中有Severe Errors**
- **找不到所给出的源程序文件**

### 3.4 连接

在对源文件进行编译得到目标文件之后，我们需要对目标文件进行连接，从而得到可执行文件。在这里我们

需要使用到连接工具，文件名为LINK.EXE。下面我们来看看连接的过程。

![.jpg](https://img.gyxnb.top/img002/3e3dd11040834045ad89d37cd05f550e.jpg)

输入link之后，系统提示你输入要进行连接的目标文件（【.OBJ】），而**Run File这一行则是提示你是否要指定**

**生成的可执行文件的名字**，**不指定则为【】中默认的名字**，上述图示中为指定默认可执行文件名为1.exe，

之后一直按Enter即可。

当然上述图片中有一个**警告错误：没有栈段**。在这里我们不用理会它。这之后将生成一个可执行文件1.exe

**后续直接在命令行输入1.exe即可执行该可执行文件**。

> 关于连接的作用：（仅作了解）
>
> - 当源程序很大时，我们可以将它分为多个源程序进行编译，每个源程序都将产生一个目标文件，
>   我们需要用连接程序将多个目标连接成一个可执行文件
> - 程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接在一起，
>   最终生成一个可执行文件
> - 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用于
>   生成可执行文件，需要经过连接程序将这些内容处理为最终的可执行信息。所以即使只有
>   一个源文件和没有调用某个库的时候也需要进行连接

> 简化编译和连接的方法：
>
> - 编译：masm 1.ASM；
> - 连接：link 1.OBJ；
>   上述的两个指令制定了需要编译或者连接的文件，并且用；表示生成默认的文件，
>   编译指令中；表示默认生成1.OBJ
>   连接指令中；表示默认生成1.EXE
>   效果如下图

![.jpg](https://img.gyxnb.top/img002/f58a658900ed4ac5a12df7072445ca20.jpg)

### 3.5 程序执行过程的跟踪

我们可以利用**Debug来跟踪一个程序的运行过程**，这通常是必须要做的工作。我们写的程序在逻辑上不一定

总是正确的，对于简单的错误，仔细检查一下源程序即可发现。但是对于隐藏较深的错误，就需要对程序的

执行过程进行跟踪分析才可以发现了。

这个过程我们需要借助工具debug。debug可以将程序加载入内存，设置CS:IP指向程序的入口。

具体用法如下图所示：

![debug.jpg](https://img.gyxnb.top/img002/42e4c17ee49445449d77700b1dc7fb73.jpg)

接下来可以使用R命令来看一下各个寄存器的设置情况，如下：

![r.jpg](https://img.gyxnb.top/img002/8a678d6fd2074a3988cadbb1fb5e1ec9.jpg)

可以看到此时的CS:IP指向076A:0000内存单元，也就是说第一条要执行的指令在该地址单元中。

仔细看最后面：**076A:0000 B80200 MOV AX,0002**,这里指示了第一条指令的地址、机器码、对应的

汇编的指令我们可以用u命令看一下其它的指令，如下图：

![u.jpg](https://img.gyxnb.top/img002/afdabe5b02644145bb3a41f8734e39f0.jpg)

我们可以看到076A:0000~076A:000A都是程序的机器码。

到这里我们可以来进行跟踪了，使用**T命令进行单步执行**，并观察每条指令执行后对寄存器的影响。

当然，到了**int 21这条指令时我们需要用P命令**执行，如下图：

![tp.png](https://img.gyxnb.top/img002/33846018c2b64f2aa4d790162758fdd5.png)

上图执行完INT 21之后显示出 “Program terminated normally”，返回到debug中。表示程序正常结束。

当然，需要注意的是在执行INT 21这条语句时需要用P命令去执行。

练习：在这里大家可以通过调试一个汇编程序，在每步执行后，相关寄存器内容的改变。程序如下：

![.jpg](https://img.gyxnb.top/img002/094ececa5fe04b178f0d94b98825f1d3.jpg)