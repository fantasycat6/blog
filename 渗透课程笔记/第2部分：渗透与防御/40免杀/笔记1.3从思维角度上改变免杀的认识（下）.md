# 传统杀软检测原理（一）

## **扫描技术**

1. 扫描压缩包技术：即是对压缩包案和封装文件作分析检查的技术。
2. 程序窜改防护：即是避免恶意程序借由删除杀毒侦测程序而大肆破坏电脑。
3. 修复技术：即是对恶意程序所损坏的文件进⾏还原
4. 急救盘杀毒：利用空白U盘制作急救启动盘，来检测电脑病毒。
5. 智能扫描：扫描最常用的磁盘，系统关键位置，耗时较短。
6. 全盘扫描：扫描电脑全部磁盘，耗时较长。
7. 勒索软件防护：保护电脑中的文件不被⿊客恶意加密。
8. 开机扫描：当电脑开机时自动进行扫描，可以扫描压缩文档和可能不需要的程序

## **监控技术**

1. 内存监控：当发现内存中存在病毒的时候，就会主动报警；监控所有进程；监控
2. 读取到内存中的⽂件；监控读取到内存的⽹络数据。
3. 文件监控：当发现写到磁盘上的⽂件中存在病毒，或者是被病毒感染，就会主动
4. 报警。
5. 邮件监控：当发现电⼦邮件的附件存在病毒时进⾏拦截。
6. 网页防护：组织网络攻击和不安全下载。
7. 行为防护：提醒用户户可疑的应用程序行为

# 传统杀软检测原理（二）

1. 进程行行行为监测法(沙盒模式)
   机制：通过对病毒多年年的观察、研究，有一一些行行行为是病毒的共同行行行为，而而且比比较特殊，在正常程序中，这些行行行为比比较罕 见。当程序运行行行时，监视其进程的各种行行行为，如果发现了了病毒行行行为，立立即报警。
   优缺点：
   1.优点：可发现未知病毒、可相当准确地预报未知的多数病毒；
   2.缺点：可能误报警、不不能识别病毒名称、有一一定实现难度、需要更更多的用用户参与判断；
2. 动防御技术
   主动防御并不不需要病毒特征码支支持，只要杀毒软件能分析并扫描到目目标程序的行行行为，并根据预先设定的规则，判定是否应该进行行行清除操作主动防御本来想领先于病毒，让杀毒软件自自己己变成安全工工程师来分析病毒，从而而达到以不不变应万变的境界。但是，计算机的智能总是在一一系列列的规则下诞生生，而而普通用用户的技术水水平达不不到专业分析病毒的水水平，两者之间的博弈将主动防御推上一一个尴尬境地。
3. 机器器学习识别技术
4. https://bbs.pediy.com/thread-272298.htm
5. 机器器学习识别技术既可以做静态样本的二二进制分析，又又可以运用用在沙箱动态行行行为分析当中，是为内容/行行行为+算法模式。伴随着深度学习的急速发展，各家厂厂商也开始尝试运用用深度学习技术来识别病毒特征，如瀚思科技的基于深度学习的二二进制恶意样本检测

# 从特征码角度去测试杀软的逻辑（一）

1. 常见的特征码定位工具有CCL、MYCCL。工具大致原理就是分割文件，某些分割部分填入数据(0)，如果扫描该部分不报警，则特征码在这个部分。如此反复，直到找到很短的某一段内容。不同工具之前局别是使用的分割算法不同，查找特征码的效果不同。

   > 目前比较常有名气的特征码定位器主要有CCL与MYCCL，他们都采用文件分块定位的办法，定位效果带有运气成份，且可能每次定位出的位置都不尽相同，这个免杀带来了困难。
   >

   后来出来了一款新的特征码定位软件 `VirTest`。下面是作者自己的介绍：

   > 我们可以这样假设报毒过程，如果检测文件是PE,如果在CODE位置存在 标志A,在DATA位置存在标志B,在资源位置存在标志C,同时满足这个3个条件，那么杀软就会报毒,VIRTEST工作原理就是要找到引起报毒最后一个标志，也就是假设中的标志C。
   >

   > 因此VIRTEST采用2分排除法，测试标志C所在文件中的位置，由于被杀的文件可能存在多个 类似于ABC这样的连锁条件，所以我们必须要通过一种排除机制，先要找最靠近文件前部的连锁条件，排除掉文件尾部数据，当找到第一个连锁条件后，抹掉引标志C，再恢复尾部数据，
   >

   > 然后继续测试另外的连锁条件，直到找到最后一个连锁条件，抹掉后，整个文件免杀了，则说明特征代码被定为完毕了，所以VIRTEST绝对可以精确的定位出所有的复合特征。这比文件分块定位法先进得多，更为科学。
   >

   工具查找肯定是针对二进制文件（有源码的也编译后在检查）。
   具体用过MYCCL（使用方法自行查找），确实比手工分割文件定位方便，也可以找到某些文件的特征码，但是有些时候可能会出现非常多非常多…的被杀文件分割

# 从特征码角度去测试杀软的逻辑（二）

1.  **数据**
   如果特征码定位到数据（通过IDA/OD等确认），其实不好修改，稍微不慎就会导致程序不能运行，或者影响程序运行流程或结果。
2. 字符串，如果不影响程序逻辑，可以替换大小写；如果无关紧要的数据，随意替换；等等，看情况而定。
3. 整数，如果不影响结果，替换值，清零等等操作。
4. 地址，基本应该不能修改，具体看情况。
5. PE头数据，根据PE结构具体来看，无用数据清零或修改，有用数据看情况修改。

反正特征码定位到数据位置不容易修改（可以再试试后面的盲免杀）。

1. **代码**
2. 如果特征码定位到代码（也通过IDA/OD等确认），在不改变程序功能基础上，应用各种方法修改。
3. 等价替换汇编代码，如mov eax，0可以换成xor eax，eax，直接结果相同，二进制代码不同。
4. 交换代码顺序，在不影响逻辑的情况下。
5. 代码块移位，将代码块移动不用的内存位置，通过加入jmp addr跳过去执行，addr是新的代码块地址。
6、
7. 最后，终极修改方法，找到访问数据的代码，直接修改代码访问数据的地址，数据也可以放到其他地址了，其实就如同修改源码一样修改，肯定没有修改源码那么容易（见后）。

## 源码免杀的逻辑原理（一）

1. 这里说的是针对有源码的（二进制就别想手工了…），方法非常简单。
2. mian中屏蔽所有代码，编译，扫描。不报的话继续2，如果依然报毒，去5。
3. 放开一层（可以多层、二分也可以）函数，编译，扫描。不报的话，重复2。直到定位到某个函数或者多个函数，进入3。
4. 在函数内部屏蔽部分代码（二分），编译，扫描。不报，重复2。
5. 直到定位某段代码（无自定义内部调用），特征码在此。
6. 是不是有附加数据，或者资源存储的文件。有，单独检查该文件或者数据，方法从1开始。如果没有，那去找找PE头吧。
7. 大致流程：
8. ```cpp
   1. sub1 //未报
   2. sub1 sub2 //未报
   3. sub1 sub2 sub3 //报
   4. sub1 sub2 sub3(sub31) //未报
   5. sub1 sub2 sub3(sub31 sub32) //报
   6. sub1 sub2 sub3(sub31 sub32(sub321)) //报
   ```
   ![]()![]()
