<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:Calibri"><span style="font-size:10.5000pt"><span style="font-family:宋体">&nbsp;<span style="font-size:22px"><strong>1.1 C<span style="font-family:宋体">与汇编的关系</span></strong></span></span></span></span></span></p>

<ul>
	<li style="text-align:justify"><span style="font-size:14px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">逆向教学宗旨：从实际角度出发，实践大于理论。</span></span></span></span></li>
</ul>

<p style="text-align:justify"><span style="font-size:18px"><strong><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">（</span>1<span style="font-family:宋体">）：从实践角度看待如何学习逆向</span></span></span></strong></span></p>

<p style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">应用层技术栈：</span></span></span></span></p>

<ol>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">加密与解密（四）</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体">X86/X64/arm<span style="font-family:宋体">汇编语言</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体">windows <span style="font-family:宋体">核心编程</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px">c语言从入门到精通(第三版) （清华）</span></li>
</ol>

<p style="text-align:justify"><span style="font-size:18px"><strong><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">（</span>2<span style="font-family:宋体">）：学习逆向环境配置</span></span></span></strong></span></p>

<p style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">工具类：</span></span></span></span></p>

<ul>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">吾爱破解工具类</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">Hxd(十六进制编辑工具)</span></span></span></span></li>
</ul>

<p style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">开发类：</span></span></span></span></p>

<ol>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体">VS2008 IDE</span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体">VC6.0 SP6 IDE</span></span></span></li>
</ol>

<p style="text-align:justify"><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">（</span>3<span style="font-family:宋体">）：基本语法的学习</span></span></span></span></strong></p>

<ul>
	<li style="text-align:justify"><span style="color:#c0392b"><u><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">各种进制的转换和原理</span></span></span></span></strong></u></span></li>
</ul>

<ol>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">十进制的定义：由十个符号组成，分别是0 1 2 3 4 5 6 7 8 9 逢十进一</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">九进制的定义：由九个符号组成，分别是0 1 2 3 4 5 6 7 8 逢九进一</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">十六进制的定义：由十六个符号组成，分别是0 1 2 3 4 5 6 7 8 9 A B C D E F</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">N进制的定义：由N个符号组成 逢N进一</span></span></span></span></li>
</ol>

<ul>
	<li style="text-align:justify"><span style="color:#c0392b"><span style="font-size:18px"><u><strong><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">数据类型与逻辑运算</span></span></span></strong></u></span></span></li>
</ul>

<p style="text-align:justify"><span style="font-size:18px"><u><strong><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">​​​​​</span></span></span></strong></u></span><span style="font-size:16px">在计算机中，由于硬件的制约，数据是有长度限制的，超过数据宽度的数据会被丢弃</span></p>

<p><span style="font-size:16px">同一个数据，表示无符号数和有符号数则其含义不同</span></p>

<ol>
	<li><span style="font-size:16px">无符号数：正数</span></li>
	<li><span style="font-size:16px">有符号数：正数、负数</span></li>
</ol>

<p style="text-align:justify"><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">（</span>4<span style="font-family:宋体">）：从汇编角度看C语言结构</span></span></span></span></strong></p>

<ul>
	<li style="text-align:justify"><span style="color:#c0392b"><strong><u><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">堆栈结构</span></span></span></span></u></strong></span></li>
</ul>

<p style="text-align:justify">&nbsp;<span style="font-size:16px"> &nbsp;堆栈的原理：</span></p>

<ol>
	<li><span style="font-size:16px">&nbsp; &nbsp;临时存放一些寄存器已无法存放的数据，比如超过内存对齐的数据类型</span></li>
</ol>

<p><span style="font-size:16px">&nbsp; &nbsp;Windows分配栈时 是从高地址往低地址分配:</span></p>

<ol>
	<li><span style="font-size:16px">&nbsp; &nbsp;MOV EBX,0x13FFDC &nbsp; &nbsp; &nbsp; &nbsp;BASE</span></li>
	<li><span style="font-size:16px">&nbsp; &nbsp;MOV EDX,0x13FFDC &nbsp; &nbsp; &nbsp; &nbsp;TOP</span></li>
</ol>

<p><span style="font-size:16px">&nbsp; &nbsp;栈底和栈顶原理：</span></p>

<ol>
	<li><span style="font-size:16px">&nbsp; &nbsp;控制栈顶和栈底分别为两个固定的寄存器(EBP 基址指针寄存器 和 ESP 堆栈指针寄存器）</span></li>
	<li><span style="font-size:16px">&nbsp; &nbsp;刚开始堆栈为空，栈顶和栈底相同</span></li>
</ol>

<ul>
	<li style="text-align:justify"><span style="color:#c0392b"><u><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">标志寄存器</span></span></span></span></strong></u></span></li>
</ul>

<ol>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">进位标志CF(Carry Flag)</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">奇偶标志PF(Parity &nbsp;Flag)</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">辅助进位标志AF(Auxiliary &nbsp;Carry Flag)</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">零标志ZF(Zero &nbsp;Flag)</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">符号标志SF(Sign &nbsp;Flag)</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">溢出标志OF(Overflow &nbsp;Flag)</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">方向标志DF(Direction Flag)</span></span></span></span></li>
</ol>

<ul>
	<li style="text-align:justify"><span style="color:#c0392b"><u><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">汇编跳转和比较指令</span></span></span></span></strong></u></span></li>
</ul>

<ol>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">JCC指令</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">JMP指令</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">CALL指令</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">RET指令</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">CMP指令</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">TEST指令</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">JCC指令表</span></span></span></span></li>
</ol>

<ul>
	<li style="text-align:justify"><span style="color:#c0392b"><u><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">堆栈结构图（重点）</span></span></span></span></strong></u></span></li>
</ul>

<ol>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">​​​​​​​调用CALL又可以分为六个部分：</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">提升堆栈</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">保护现场</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">初始化提升的堆栈</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">执行实际内容</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">恢复现场</span></span></span></span></li>
	<li style="text-align:justify"><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">返回</span></span></span></span></li>
</ol>

<ul>
	<li style="text-align:justify"><span style="color:#c0392b"><u><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">反汇编分析C语言</span></span></span></span></strong></u></span></li>
</ul>

<p style="text-align:justify"><span style="color:#c0392b"><u><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">​​​​​​​​​​​</span></span></span></span></strong></u></span><span style="font-size:18px">函数内部</span></p>

<p><span style="font-size:18px">接着进到函数的内部</span></p>

<p><span style="font-size:18px">有了之前画堆栈图的经验，我们不难看出，尽管我们的函数是个空函数，但其汇编代码依然完成了以下流程：</span></p>

<ol>
	<li><span style="font-size:18px">提升堆栈</span></li>
	<li><span style="font-size:18px">保护现场</span></li>
	<li><span style="font-size:18px">初始化提升的堆栈</span></li>
	<li><span style="font-size:18px">恢复现场</span></li>
	<li><span style="font-size:18px">返回</span></li>
</ol>

<h5><span style="font-size:18px">提升堆栈</span></h5>

<pre>
<span style="font-size:18px"><em> 复制代码</em><em> 隐藏代码
</em><code>00401010&nbsp; &nbsp;push&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;ebp
00401011&nbsp; &nbsp;mov&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ebp,esp
00401013&nbsp; &nbsp;sub&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;esp,40h</code></span></pre>

<h5><span style="font-size:18px">保护现场</span></h5>

<pre>
<span style="font-size:18px"><em> 复制代码</em><em> 隐藏代码
</em><code>00401016&nbsp; &nbsp;push&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;ebx
00401017&nbsp; &nbsp;push&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;esi
00401018&nbsp; &nbsp;push&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;edi</code></span></pre>

<p><span style="font-size:18px">PS：前面的push&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;ebp也是保护现场</span></p>

<h5><span style="font-size:18px">初始化提升的堆栈</span></h5>

<pre>
<span style="font-size:18px"><em> 复制代码</em><em> 隐藏代码
</em><code>00401019&nbsp; &nbsp;lea&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;edi,[ebp-40h]
0040101C&nbsp; &nbsp;mov&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ecx,10h
00401021&nbsp; &nbsp;mov&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;eax,0CCCCCCCCh
00401026&nbsp; &nbsp;rep stos&nbsp; &nbsp; dword ptr [edi]</code></span></pre>

<h5><span style="font-size:18px">恢复现场</span></h5>

<pre>
<span style="font-size:18px"><em> 复制代码</em><em> 隐藏代码
</em><code>00401028&nbsp; &nbsp;pop&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;edi
00401029&nbsp; &nbsp;pop&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;esi
0040102A&nbsp; &nbsp;pop&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ebx
0040102B&nbsp; &nbsp;mov&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;esp,ebp
0040102D&nbsp; &nbsp;pop&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ebp</code></span></pre>

<pre>
<code class="language-cpp">//空函数        
void function(){

}

int main(int argc, char* argv[])
{
    //调用空函数
        function();
        return 0;
}</code></pre>

<ul>
	<li style="text-align:justify"><span style="color:#c0392b"><u><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">C语言内联汇编和调用协定</span></span></span></span></strong></u></span></li>
</ul>

<pre>
<code>int __declspec (naked) Plus(int x,int y){
                __asm{
                //保留调用前堆栈
                push ebp
                //提升堆栈
                mov ebp,esp
                sub esp,0x40
                //保护现场
                push ebx
                push esi
                push edi
                //初始化提升的堆栈，填充缓冲区
                mov eax,0xCCCCCCCC
                mov ecx,0x10
                lea edi,dword ptr ds:[ebp-0x40]
                rep stosd
                //函数核心功能

                //取出参数
                mov eax,dword ptr ds:[ebp+8]
                //参数相加
                add eax,dword ptr ds:[ebp+0xC]

                //恢复现场
                pop edi
                pop esi
                pop ebx

                //降低堆栈
                mov esp,ebp
                pop ebp                

                //返回
                ret 
        }        
}</code></pre>

<p style="text-align:justify">&nbsp;</p>

<pre>
<code>void __declspec (naked) function(){
        __asm{
                ret
        }
}</code></pre>

<ul>
	<li style="text-align:justify"><span style="color:#c0392b"><u><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">汇编寻找C程序入口</span></span></span></span></strong></u></span></li>
</ul>

<ol>
	<li style="text-align:justify">mainCRTStartup 和&nbsp;&nbsp;wmainCRTStartup 是控制台环境下多字节编码和Unicode 编码的启动函数</li>
	<li style="text-align:justify">而WinMainCRTStartup&nbsp;&nbsp;和wWinMainCRTStartup 是windows 环境下多字节编码和Unicode 编码的启动函数</li>
</ol>

<p style="text-align:justify">mainCRTStartup做了哪些事：</p>

<p style="text-align:justify"><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/2446/1638175874000/d7e8c05ca5a843948525ddcbf6db07b9.png" style="height:240px; width:1386px" /></p>

<h4>&nbsp;</h4>

<ol>
	<li><span style="font-size:18px">前面我们已经知道了mainCRTStartup也就是程序入口，那么如何通过mainCRTStartup来找到main函数入口</span></li>
	<li><span style="font-size:18px">根据函数的参数来进行判断</span></li>
	<li><span style="font-size:18px">main函数貌似只有两个参数，但实际上main函数一共有三个参数，只不过一般第三个参数我们并没有用到，于是在使用main函数时并没有加上，完整的main函数原型如下:</span></li>
</ol>

<pre>
<em> </em><em>
</em><span style="font-size:18px"><code>int main(int argc,char *argv[],char *envp[]){}</code></span></pre>

<p><span style="font-size:18px">这里的argv和envp对应mainCRTStartup里_setargv()和_setenvp()</span></p>

<p><span style="font-size:18px">main函数的三个参数：</span></p>

<p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/2446/1638175874000/eacff80fa91044e28df8e670e9ed1e35.png" style="height:122px; width:819px" /></p>

<ul>
	<li style="text-align:justify"><span style="color:#c0392b"><u><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">汇编C语言基本类型</span></span></span></span></strong></u></span></li>
</ul>

<p style="text-align:justify"><span style="color:#c0392b"><u><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">​​​​​​​​​​</span></span></span></span></strong></u></span></p>

<p>&nbsp;</p>

<pre>
<code class="language-cpp">#include "stdafx.h"
int main(int argc, char* argv[])
{
        char a=0xFF;
        short b=0xFF;
        int c=0xFF;
        long d=0xFF;
        return 0;
}</code></pre>

<ul>
	<li style="text-align:justify"><span style="color:#c0392b"><u><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">汇编 全局和局部 变量</span></span></span></span></strong></u></span></li>
</ul>

<p style="text-align:justify"><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/2446/1638175874000/414b76cc64ff4c4292c015b238247f76.png" style="height:188px; width:1177px" /></p>

<h2>全局变量</h2>

<ol>
	<li>
	<p><span style="font-size:18px"><code>MOV&nbsp;&nbsp;寄存器,byte/word/dword ptr ds:[0x12345678]</code></span></p>
	</li>
	<li>
	<p><span style="font-size:18px">上面的0x12345678是固定的地址，每次程序启动都不变</span></p>

	<p><span style="font-size:18px">通过寄存器的宽度，或者byte/word/dword&nbsp;&nbsp;来判断全局变量的宽度</span></p>
	</li>
	<li>
	<p><span style="font-size:18px">全局变量就是所谓的基址</span></p>
	</li>
</ol>

<h2>局部变量</h2>

<ol>
	<li>
	<p><span style="font-size:18px">局部变量在程序编译完成后并没有分配固定的地址</span></p>
	</li>
	<li>
	<p><span style="font-size:18px">在所属的方法没有被调用时，局部变量并不会分配内存地址，只有当所属的程序被调用了，才会在堆栈中分配内存</span></p>
	</li>
	<li>
	<p><span style="font-size:18px">当局部变量所属的方法执行完毕后，局部变量所占用的内存将变成垃圾数据.局部变量消失</span></p>
	</li>
	<li>
	<p><span style="font-size:18px">局部变量只能在函数内部使用，函数A无法使用函数B的局部变量</span></p>
	</li>
	<li>
	<p><span style="font-size:18px">局部变量的反汇编识别</span></p>

	<p><span style="font-size:18px">[ebp-4]</span></p>

	<p><span style="font-size:18px">[ebp-8]</span></p>

	<p><span style="font-size:18px">[ebp-0xC]</span></p>

	<div style="text-align:start">
	<div>
	<div>
	<div>
	<div>
	<div>
	<div>
	<div>
	<h2><span style="color:#000000; font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Tahoma,PingFang SC,Hiragino Sans GB,Microsoft Yahei,Simsun,sans-serif"><span style="font-size:24px"><strong>例子</strong></span></span></h2>

	<pre>
<code class="language-cpp">#include "stdafx.h"
//全局变量
int global=0x610;
int main(int argc, char* argv[])
{
    //局部变量
        int temp=0x160;

        global=global+temp;

        return 0;
}</code></pre>

	<ol>
		<li>&nbsp;</li>
	</ol>
	</div>
	</div>
	</div>
	</div>
	</div>
	</div>
	</div>
	</div>
	</li>
</ol>

<ul>
	<li style="text-align:justify"><span style="color:#c0392b"><u><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">汇编C语言类型转换</span></span></span></span></strong></u></span></li>
</ul>

<p style="text-align:justify">&nbsp;</p>

<h2 style="text-align:justify"><span style="font-size:18px">&nbsp; &nbsp; &nbsp;类型转换相关汇编指令</span></h2>

<ol>
	<li>
	<h3 style="text-align:justify"><span style="font-size:18px">MOVSX</span></h3>
	</li>
	<li style="text-align:justify"><span style="font-size:18px">先<strong>符号</strong>扩展,再传送</span></li>
	<li>
	<pre>
<code>MOV AL,0FF
MOVSX CX,AL
MOV AL,80
MOVSX CX,AL</code></pre>
	</li>
	<li>
	<h3 style="text-align:justify"><span style="font-size:18px">MOVZX</span></h3>
	</li>
	<li>先<strong>零</strong>扩展,再传送</li>
	<li>
	<pre>
<code>MOV AL,0FF
MOVZX CX,AL
MOV AL,80
MOVSX CX,AL</code></pre>
	</li>
	<li style="text-align:justify">
	<pre>
<code class="language-cpp">#include "stdafx.h"
int main(int argc, char* argv[])
{
        unsigned char i=0xFF;
        printf("%d\n",i);
        int j=i+1;
        i=i+1;
        printf("%d\n",i);
        printf("%d\n",j);
        return 0;
}</code></pre>
	</li>
</ol>

<ul>
	<li style="text-align:justify"><span style="color:#c0392b"><u><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">汇编嵌套if else</span></span></span></span></strong></u></span></li>
</ul>

<ol>
	<li>
	<pre>
<code class="language-cpp">#include "stdafx.h"

int result=0;
int getMax(int i,int j,int k){
        if(i&gt;j){
                if(i&gt;k){
                        return i;
                }else{
                        return k;
                }

        }else{
                if(j&gt;k){
                        return j;
                }else{
                        return k;
                }
        }
}

int main(int argc, char* argv[])
{
        result=getMax(1,2,3);
        printf("%d\n",result);
        result=getMax(1,3,2);
        printf("%d\n",result);
        result=getMax(2,1,3);
        printf("%d\n",result);
        result=getMax(2,3,1);
        printf("%d\n",result);
        result=getMax(3,1,2);
        printf("%d\n",result);
        result=getMax(3,2,1);
        printf("%d\n",result);
        return 0;
}</code></pre>
	</li>
	<li>
	<pre>
<code class="language-cpp">#include "stdafx.h"
int getMax2(int i,int j){
        if(i&gt;j){
                return i;
        }else{
                return j;
        }
}
int main(int argc, char* argv[])
{
        getMax2(1,2);
        return 0;
}</code></pre>
	</li>
</ol>

<ul>
	<li style="text-align:justify"><span style="color:#c0392b"><u><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">汇编比较三种循环</span></span></span></span></strong></u></span></li>
</ul>

<ol>
	<li style="text-align:justify">
	<pre>
<code class="language-cpp">#include "stdafx.h"
int loop1(){
        int i=0,j=0;
        for(i=0;i&lt;10;i++){
                j=j+i;
        }
        return j;
}

int loop2(){
        int i=0,j=0;
        while(i&lt;10){
                j=j+i;
                i=i+1;
        }
        return j;
}
int loop3(){
        int i=0,j=0;
        do {
                j=j+i;
                i=i+1;
        } while(i&lt;10);
        return j;
}

int main(int argc, char* argv[])
{
        int result=0;
        result=loop1();
        printf("%d\n",result);
        result=loop2();
        printf("%d\n",result);
        result=loop3();
        printf("%d\n",result);
        return 0;
}</code></pre>
	</li>
</ol>

<ul>
	<li style="text-align:justify"><span style="color:#c0392b"><u><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">汇编一维数组</span></span></span></span></strong></u></span></li>
</ul>

<ol>
	<li style="text-align:justify">
	<h3>数组的寻址</h3>

	<p>数组的存储并不复杂，接下来看看如何来找到数组的某个成员</p>

	<pre>
<code class="language-cpp">#include "stdafx.h"
void  function(){
        int x=1;
        int y=2;
        int r=0;
        int arr[5]={1,2,3,4,5};
        r=arr[1];
        r=arr[x];
        r=arr[x+y];
        r=arr[x*2+y];
}
int main(int argc, char* argv[])
{
        function();
        return 0;
}</code></pre>
	</li>
</ol>

<p style="text-align:justify">&nbsp;</p>

<ol>
	<li>
	<pre>
<code class="language-cpp">#include "stdafx.h"
void  function(){
        int arr[5]={1,2,3,4,5};
}
int main(int argc, char* argv[])
{
        function();
        return 0;
}</code></pre>
	</li>
</ol>

<p style="text-align:justify"><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp;数组越界的应用</span></p>

<p style="text-align:justify">&nbsp;</p>

<ol>
	<li>
	<pre>
<code class="language-cpp">#include "stdafx.h"
void  function(){
        int arr[5]={1,2,3,4,5};
        arr[6]=0x12345678;

}
int main(int argc, char* argv[])
{
        function();
        return 0;
}</code></pre>
	</li>
</ol>

<ul>
	<li style="text-align:justify"><span style="color:#c0392b"><u><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">汇编二维数组位移 乘法</span></span></span></span></strong></u></span></li>
</ul>

<p style="text-align:justify">&nbsp;</p>

<ol>
	<li>
	<pre>
<code class="language-cpp">        int i=1;
        i=i*4;
        i=i*8;
        i=i*16;</code></pre>
	</li>
	<li>
	<pre>
<code class="language-cpp">int arr[3][4]={
                {1,2,3,4},
                {5,6,7,8},
                {9,10,11,12}
        };
int a=arr[2][3];
int i=1,j=2;
int b=arr[i][j];
int c=arr[i+j][i*2];</code></pre>
	</li>
	<li style="text-align:justify">
	<pre>
<code class="language-cpp">int arr[3][4]={
                {1,2,0,0},
                {5,6,7,0},
                {9,0,0,0}
        };</code></pre>
	</li>
	<li style="text-align:justify">
	<pre>
<code class="language-cpp">int arr[3][4]={
                {1,2},
                {5,6,7},
                {9}
        };</code></pre>
	</li>
</ol>

<ul>
	<li style="text-align:justify"><span style="color:#c0392b"><u><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">汇编 结构体和内存对齐</span></span></span></span></strong></u></span></li>
</ul>

<ol>
	<li style="text-align:justify">
	<pre>
<code class="language-cpp">#include "stdafx.h"
#include &lt;string.h&gt;
struct Player{
    float hp;                //人物血量
    float mp;                //人物魔力值
    int money;                //人物金钱
    int atk;                //人物攻击力
    char name[10];        //人物昵称
    float x;                //人物x坐标
    float y;                //人物y坐标
};
int main(int argc, char* argv[])
{
        Player player;

        player.hp=100;
        player.mp=50;
        player.money=1000;
        player.atk=10;        
        strcpy(player.name,"lyl610abc");
        player.x=600;
        player.y=100;
        return 0;
}</code></pre>
	</li>
	<li>
	<pre>
<code class="language-cpp">#include "stdafx.h"
#include &lt;string.h&gt;
struct Player{
    float hp;                //人物血量
    float mp;                //人物魔量
    int money;                //人物金钱
    int atk;                //人物攻击力
    char name[10];        //人物昵称
    float x;                //人物x坐标
    float y;                //人物y坐标
};

Player retStruct(){

        Player player;
        return player;
}

int main(int argc, char* argv[])
{

        Player player;
        player=retStruct();

        return 0;
}</code></pre>
	</li>
</ol>

<p style="text-align:justify">&nbsp;</p>

<h2 style="text-align:justify"><strong><span style="font-size:18px">内存对齐</span></strong></h2>

<ol>
	<li style="text-align:justify"><span style="font-size:18px">内存对齐也称作字节对齐</span></li>
	<li style="text-align:justify"><span style="font-size:18px">前面或多或少都有提到过内存对齐，但没有具体展开，现在来谈谈内存对齐</span></li>
	<li>
	<h3 style="text-align:justify"><span style="font-size:18px">为什么要内存对齐</span></h3>
	</li>
</ol>

<h4 style="text-align:justify"><strong><span style="font-size:18px">性能原因</span></strong></h4>

<ol>
	<li style="text-align:justify"><span style="font-size:18px">寻址时提高效率，采用了以空间换时间的思想</span></li>
	<li style="text-align:justify"><span style="font-size:18px">当寻址的内存的单位和本机宽度一致时，寻址的效率最高</span></li>
</ol>

<p style="text-align:justify"><span style="font-size:18px"><strong>举个例子：</strong></span></p>

<ol>
	<li><span style="font-size:18px">在32位的机器上，一次读32位（4字节）的内存 效率最高</span></li>
	<li><span style="font-size:18px">在64位的机器上，一次读64位（8字节）的内存 效率最高</span></li>
</ol>

<ul>
	<li style="text-align:justify"><span style="color:#c0392b"><u><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">汇编switch比较if else</span></span></span></span></strong></u></span></li>
</ul>

<ol>
	<li style="text-align:justify">
	<pre>
<code class="language-cpp">#include "stdafx.h"

void MySwitch(int x){        
        switch(x) {
        case 1:
                printf("num is 1\n");
                break;
        case 2:
                printf("num is 2\n");
                break;
        case 3:
                printf("num is 3\n");
                break;
        default:
                printf("no cases match\n");
                break;
        }
}

int main(int argc, char* argv[])
{
        MySwitch(2);
        return 0;
}</code></pre>
	</li>
	<li style="text-align:justify">
	<p><span style="font-size:18px">switch（表达式)中，表达式应该为整数类型：char short int long，其它类型诸如：float、double等类型均不可以</span></p>

	<p><span style="font-size:18px">switch搭配case使用，case里如果没有添加break语句则会继续向下执行下面的case</span></p>

	<p><span style="font-size:18px">default语句可以没有，如果所有case都不匹配会默认执行default语句</span></p>
	</li>
</ol>

<ul>
	<li style="text-align:justify"><span style="color:#c0392b"><u><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">汇编角度看C指针模型</span></span></span></span></strong></u></span></li>
</ul>

<ol>
	<li style="text-align:justify">
	<pre>
<code class="language-cpp">void function(){                
        char* a;
        a=(char*) 610;
    int** b;
    b=(int**) 610;
}</code></pre>
	</li>
	<li>
	<pre>
<code class="language-cpp">void function(){                
        int a;
    a=610;
    a=(int)610;
}</code></pre>
	</li>
	<li>
	<pre>
<code class="language-cpp">void function(){                
        char* a;
        short* b;
        int* c;
        a=(char*)  1;
        b= (short*) 2;
        c=(int*)  3;
}</code></pre>
	</li>
</ol>

<ol>
	<li>
	<pre>
<code class="language-cpp">#include "stdafx.h"

void function(){                
        char* a;
        short* b;
        int* c;
        a=(char*)  1;
        b= (short*) 2;
        c=(int*)  3;

        a++;
        b++;
        c++;

        printf("a:%d\t b:%d\tc:%d\n",a,b,c);

}

int main(int argc, char* argv[])
{
        function();
        return 0;
}</code></pre>
	</li>
</ol>

<p style="text-align:justify"><strong><span style="font-size:18px"><span style="font-family:Calibri"><span style="font-family:宋体"><span style="font-family:宋体">（</span>4<span style="font-family:宋体">）：编译器原理</span></span></span></span></strong></p>

<p style="text-align:justify">&nbsp;</p>

<ol>
	<li><span style="font-size:18px">编译一个程序一般由预处理器、解释器、汇编器、链接器、加载器等组成，进而将一个高级语言编译成机器可以执行的二进制语言。</span></li>
</ol>

<ul>
	<li><span style="font-size:18px">预处理器</span></li>
</ul>

<ol>
	<li><span style="font-size:18px">主要进行宏处理，文件包含，语言拓展等。</span></li>
</ol>

<ul>
	<li><span style="font-size:18px">解释器</span></li>
</ul>

<ol>
	<li><span style="font-size:18px">将一个高级语言转化成一个机器语言，解释器从输入中读取一句，将其变成中间代码，执行它，再读取下一句，如果有错误发生，则解释器停止执行并且报告错误。</span></li>
</ol>

<ul>
	<li><span style="font-size:18px">汇编器</span></li>
</ul>

<ol>
	<li><span style="font-size:18px">将汇编语言转化成机器语言，汇编器的输出文件叫做目标文件，是一系列机器指令的集合，并且将它们存放到内存中去。</span></li>
</ol>

<ul>
	<li><span style="font-size:18px">链接器</span></li>
</ul>

<ol>
	<li><span style="font-size:18px">其作用是将一些目标文件连接起来形成一个可执行文件，所有这些文件可能有不同的汇编器汇编的，链接器的作用是寻找定位程序的参考模块，决定代码被加载到内存位置。</span></li>
</ol>

<ul>
	<li><span style="font-size:18px">加载器</span></li>
</ul>

<ol>
	<li><span style="font-size:18px">加载器是</span>操作系统的一部分，负责加载可执行文件并且执行它们，它计算程序的大小，为其创造内存空间，初始化多个寄存器来进行执行初始化。</li>
</ol>

<p style="text-align:justify">&nbsp;</p>
